#!/usr/bin/python3
# Copyright (c) 2022 Sam Blenny
# SPDX-License-Identifier: MIT
#
# Generate source code for Markab VM memory map, CPU opcodes, and enum codes
#
import re
from os.path import basename


C_HEADER_OUTFILE = "libmkb/autogen.h"
C_CODE_OUTFILE = "libmkb/autogen.c"

OPCODES = """
nop NOP
reset RESET
halt HALT
tron TRON
troff TROFF
>err MTE
<ASM> U8
<ASM> U16
<ASM> I32
<ASM> STR
<ASM> BZ
<ASM> JMP
<ASM> JAL
<ASM> RET
call CALL
@ LB
! SB
h@ LH
h! SH
w@ LW
w! SW
1+ INC
1- DEC
+ ADD
- SUB
* MUL
/ DIV
% MOD
<< SLL
>> SRL
>>> SRA
inv INV
xor XOR
or OR
and AND
> GT
< LT
= EQ
!= NE
0= ZE
true TRUE
false FALSE
drop DROP
dup DUP
over OVER
swap SWAP
pc PC
r R
>r MTR
rdrop RDROP
emit EMIT
hex HEX
decimal DECIMAL
base BASE
print PRINT
. DOT
.S DOTS
.Sh DOTSH
.Rh DOTRH
dump DUMP
"""

MEMORY_MAP = """
0000 Heap     # Heap (dictionary)                        56 KB
E000 HeapRes  # Heap Reserve buffer                      256 bytes
E0FF HeapMax  # Heap: end of reserve buffer
E100 DP       # Dictionary Pointer                       2 bytes (align 4)
#...
FFFF MemMax
"""

CONSTANTS = """
# Codes for dictionary entry Types
T_VAR    0   # Variable
T_CONST  1   # Constant
T_OP     2   # Single opcode for a simple word
T_OBJ    3   # Object code for regular compiled word
T_IMM    4   # Object code for immediate compiled word
"""

def filter(src):
  """Filter a comments and blank lines out of heredoc-style source string"""
  lines = src.strip().split("\n")
  lines = [L.split("#")[0].strip() for L in lines]    # filter comments
  lines = [L for L in lines if len(L) > 0]            # filter empty lines
  lines = [" ".join(re.split(r' +', L)) for L in lines] # merge repeated spaces
  return lines

def c_addresses():
  addrs = []
  for line in filter(MEMORY_MAP):
    (addr, name) = line.split(" ")
    addrs += [f"#define MK_{name:9} (0x{addr})"]
  return "\n".join(addrs)

def c_opcode_constants():
  ops = []
  for (i, line) in enumerate(filter(OPCODES)):
    (name, opcode) = line.strip().split(" ")
    ops += [f"#define MK_{opcode.upper():6} (0x{i:02x}  /* {i:2} */)"]
  return "\n".join(ops)

def c_enum_codes():
  constants = []
  for line in filter(CONSTANTS):
    (name, code) = line.split(" ")
    fmt_name = f"{name}"
    constants += [f"#define MK_{fmt_name:11} ({code})"]
  return "\n".join(constants)

def c_opcode_dictionary():
  ope = []
  for (i, line) in enumerate(filter(OPCODES)):
    (name, opcode) = line.strip().split(" ")
    key = f'"{opcode.upper()}",'
    ope += [f"    {key:9}  /* {i:>2} */"]
  return "\n".join(ope)

def c_core_vocab_len():
  a = len(filter(MEMORY_MAP))
  b = len(filter(CONSTANTS))
  c = len(filter(OPCODES))
  return a + b + c

def c_opcodes_len():
  return len(filter(OPCODES))

def c_core_vocab():
  cv = []
  for line in filter(MEMORY_MAP):
    (addr, name) = line.split(" ")
    key = f"{{\"{name}\"}},"
    cv += [f"""    {{ {key:16} MK_T_CONST, 0x{addr:7} }},"""]
  for line in filter(CONSTANTS):
    (name, code) = line.split(" ")
    key = f"{{\"{name}\"}},"
    cv += [f"""    {{ {key:16} MK_T_CONST, {code:9} }},"""]
  for (i, line) in enumerate(filter(OPCODES)):
    (name, code) = line.strip().split(" ")
    if name == '<ASM>':
      continue
    key = f"{{\"{name}\"}},"
    cv += [f"""    {{ {key:16} MK_T_OP,    MK_{code:6} }},"""]
  return "\n".join(cv)

def c_bytecode_switch_guts():
  s = []
  for (i, line) in enumerate(filter(OPCODES)):
    (name, opcode) = line.strip().split(" ")
    s += [f"            case {i}:"]
    if opcode != 'NOP':
      s += [f"                op_{opcode.upper()}(ctx);"]
    else:
      # Don't pass context to NOP; this stops a Plan 9 C compiler warning
      s += [f"                op_{opcode.upper()}();"]
    s += [f"                break;"]
  s += ["            default:"]
  s += ["                vm_irq_err(MK_ERR_BAD_OPCODE);"]
  s += ["                ctx->halted = 1;"]
  return "\n".join(s)


C_HEADER_TEMPLATE = f"""
/* Copyright (c) 2023 Sam Blenny
 * SPDX-License-Identifier: MIT
 *
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DO NOT MAKE EDITS HERE
 * See codegen.py for details
 *
 * NOTE: This relies on typedefs from libmkb.h. This does not inlcude libmkb.h
 *       so you need to arrange for that on your own. Doing it this way makes
 *       it easier to build on POSIX systems and Plan 9 without a lot of chaos
 *       around different platform assumptions about header include paths.
 */
#ifndef LIBMKB_AUTOGEN_H
#define LIBMKB_AUTOGEN_H

/* Markab VM opcode constants */
{c_opcode_constants()}

/* Markab VM opcode dictionary */
#define MK_OPCODES_LEN ({c_opcodes_len()})
static const char * const opcodes[MK_OPCODES_LEN];

/* Markab VM memory map */
{c_addresses()}

/* Markab language enum codes */
{c_enum_codes()}

/* Markab language core vocabulary */
#define MK_CORE_VOC_LEN ({c_core_vocab_len()})
#define MK_VOC_ITEM_NAME_LEN (16)
typedef struct mk_voc_item {{
    const char * const name[MK_VOC_ITEM_NAME_LEN];
    const u8 type_code;
    const u32 value;
}} mk_voc_item_t;
static const mk_voc_item_t mk_core_voc[MK_CORE_VOC_LEN];

#endif /* LIBMKB_AUTOGEN_H */
""".strip()

C_CODE_TEMPLATE = f"""
/* Copyright (c) 2023 Sam Blenny
 * SPDX-License-Identifier: MIT
 *
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DO NOT MAKE EDITS HERE
 * See codegen.py for details
 */
#ifndef LIBMKB_AUTOGEN_C
#define LIBMKB_AUTOGEN_C

#include "libmkb.h"
#include "autogen.h"

/* Markab VM opcode dictionary */
static const char * const opcodes[MK_OPCODES_LEN] = {{
{c_opcode_dictionary()}
}};

/* Markab language core vocabulary */
static const mk_voc_item_t core_voc[MK_CORE_VOC_LEN] = {{
{c_core_vocab()}
}};

/*
 * This is the bytecode interpreter. The for-loop here is a very, very hot code
 * path, so we need to be careful to help the compiler optimize it well. With
 * that in mind, this code expects to be #included into libmkb.c, which also
 * #includes op.c. That arrangement allows the compiler to inline opcode
 * implementations into the big switch statement.
 */
static void autogen_step(mk_context_t * ctx) {{
    int i; /* declare outside of for loop for ANSI C compatibility */
    for(i=0; i<MK_MAX_CYCLES; i++) {{
        switch(vm_next_instruction(ctx)) {{
{c_bytecode_switch_guts()}
        }};
        if(ctx->halted) {{
            return;
        }}
    }}
    /* Making it this far means the MK_MAX_CYCLES limit was exceeded */
    vm_irq_err(MK_ERR_CPU_HOG);
    autogen_step(ctx);
}};

#endif /* LIBMKB_AUTOGEN_C */
""".strip()

with open(C_HEADER_OUTFILE, 'w') as f:
  f.write(C_HEADER_TEMPLATE)
  f.write("\n")

with open(C_CODE_OUTFILE, 'w') as f:
  f.write(C_CODE_TEMPLATE)
  f.write("\n")
