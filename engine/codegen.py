#!/usr/bin/python3
# Copyright (c) 2022 Sam Blenny
# SPDX-License-Identifier: MIT
#
# Generate source code for Markab VM memory map, CPU opcodes, and enum codes
#
import re
from os.path import basename


C_HEADER_OUTFILE = "libmkb/autogen.h"
C_CODE_OUTFILE = "libmkb/autogen.c"

OPCODES = """
nop NOP
halt HALT
<ASM> U8
<ASM> U16
<ASM> I32
<ASM> STR
<ASM> BZ
<ASM> BNZ
<ASM> JMP
<ASM> JAL
<ASM> RET
call CALL
@ LB
! SB
h@ LH
h! SH
w@ LW
w! SW
++ INC
-- DEC
+ ADD
- SUB
neg NEG
* MUL
/ DIV
% MOD
<< SLL
>> SRL
>>> SRA
~ INV
^ XOR
| OR
& AND
|| ORL
&& ANDL
> GT
< LT
>= GTE
<= LTE
== EQ
!= NE
drop DROP
dup DUP
over OVER
swap SWAP
r R
>r MTR
rdrop RDROP
emit EMIT
print PRINT
cr CR
. DOT
.h DOTH
.S DOTS
.Sh DOTSH
.Rh DOTRH
dump DUMP
"""

def filter(src):
  """Filter a comments and blank lines out of heredoc-style source string"""
  lines = src.strip().split("\n")
  lines = [L.split("#")[0].strip() for L in lines]    # filter comments
  lines = [L for L in lines if len(L) > 0]            # filter empty lines
  lines = [" ".join(re.split(r' +', L)) for L in lines] # merge repeated spaces
  return lines

def c_opcode_constants():
  ops = []
  for (i, line) in enumerate(filter(OPCODES)):
    (name, opcode) = line.strip().split(" ")
    ops += [f"#define MK_{opcode.upper():6} (0x{i:02x}  /* {i:2} */)"]
  return "\n".join(ops)

def c_bytecode_switch_guts():
  s = []
  for (i, line) in enumerate(filter(OPCODES)):
    (name, opcode) = line.strip().split(" ")
    s += [f"            case {i}:"]
    if not (opcode in ['NOP', 'CR']):
      s += [f"                op_{opcode.upper()}(ctx);"]
    else:
      # Don't pass context to NOP, CR, etc because they don't use it
      s += [f"                op_{opcode.upper()}();"]
    s += [f"                break;"]
  s += ["            default:"]
  s += ["                vm_irq_err(ctx, MK_ERR_BAD_OPCODE);"]
  s += ["                ctx->halted = 1;"]
  return "\n".join(s)


C_HEADER_TEMPLATE = f"""
/* Copyright (c) 2023 Sam Blenny
 * SPDX-License-Identifier: MIT
 *
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DO NOT MAKE EDITS HERE
 * See codegen.py for details
 */
#ifndef LIBMKB_AUTOGEN_H
#define LIBMKB_AUTOGEN_H

/* Markab VM opcode constants */
{c_opcode_constants()}

#endif /* LIBMKB_AUTOGEN_H */
""".strip()

C_CODE_TEMPLATE = f"""
/* Copyright (c) 2023 Sam Blenny
 * SPDX-License-Identifier: MIT
 *
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DO NOT MAKE EDITS HERE
 * See codegen.py for details
 */
#ifndef LIBMKB_AUTOGEN_C
#define LIBMKB_AUTOGEN_C

#include "libmkb.h"
#include "autogen.h"

/*
 * This is the bytecode interpreter. The for-loop here is a very, very hot code
 * path, so we need to be careful to help the compiler optimize it well. With
 * that in mind, this code expects to be #included into libmkb.c, which also
 * #includes op.c. That arrangement allows the compiler to inline opcode
 * implementations into the big switch statement.
 */
static void autogen_step(mk_context_t * ctx) {{
    int i; /* declare outside of for loop for ANSI C compatibility */
    for(i=0; i<MK_MAX_CYCLES; i++) {{
        switch(vm_next_instruction(ctx)) {{
{c_bytecode_switch_guts()}
        }};
        if(ctx->halted) {{
            return;
        }}
    }}
    /* Making it this far means the MK_MAX_CYCLES limit was exceeded */
    vm_irq_err(ctx, MK_ERR_CPU_HOG);
    autogen_step(ctx);
}};

#endif /* LIBMKB_AUTOGEN_C */
""".strip()

with open(C_HEADER_OUTFILE, 'w') as f:
  f.write(C_HEADER_TEMPLATE)
  f.write("\n")

with open(C_CODE_OUTFILE, 'w') as f:
  f.write(C_CODE_TEMPLATE)
  f.write("\n")
