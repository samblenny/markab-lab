/* Copyright (c) 2023 Sam Blenny
 * SPDX-License-Identifier: MIT
 *
 * THIS FILE IS AUTOMATICALLY GENERATED
 * DO NOT MAKE EDITS HERE
 * See codegen.py for details
 */
#ifndef LIBMKB_AUTOGEN_C
#define LIBMKB_AUTOGEN_C

#include "libmkb.h"
#include "autogen.h"

/*
 * This is the bytecode interpreter. The for-loop here is a very, very hot code
 * path, so we need to be careful to help the compiler optimize it well. With
 * that in mind, this code expects to be #included into libmkb.c, which also
 * #includes op.c. That arrangement allows the compiler to inline opcode
 * implementations into the big switch statement.
 */
static void autogen_step(mk_context_t * ctx) {
    int i; /* declare outside of for loop for ANSI C compatibility */
    for(i=0; i<MK_MAX_CYCLES; i++) {
        switch(vm_next_instruction(ctx)) {
            case 0:
                op_NOP();
                break;
            case 1:
                op_HALT(ctx);
                break;
            case 2:
                op_U8(ctx);
                break;
            case 3:
                op_U16(ctx);
                break;
            case 4:
                op_I32(ctx);
                break;
            case 5:
                op_STR(ctx);
                break;
            case 6:
                op_BZ(ctx);
                break;
            case 7:
                op_JMP(ctx);
                break;
            case 8:
                op_JAL(ctx);
                break;
            case 9:
                op_RET(ctx);
                break;
            case 10:
                op_CALL(ctx);
                break;
            case 11:
                op_LB(ctx);
                break;
            case 12:
                op_SB(ctx);
                break;
            case 13:
                op_LH(ctx);
                break;
            case 14:
                op_SH(ctx);
                break;
            case 15:
                op_LW(ctx);
                break;
            case 16:
                op_SW(ctx);
                break;
            case 17:
                op_INC(ctx);
                break;
            case 18:
                op_DEC(ctx);
                break;
            case 19:
                op_ADD(ctx);
                break;
            case 20:
                op_SUB(ctx);
                break;
            case 21:
                op_MUL(ctx);
                break;
            case 22:
                op_DIV(ctx);
                break;
            case 23:
                op_MOD(ctx);
                break;
            case 24:
                op_SLL(ctx);
                break;
            case 25:
                op_SRL(ctx);
                break;
            case 26:
                op_SRA(ctx);
                break;
            case 27:
                op_INV(ctx);
                break;
            case 28:
                op_XOR(ctx);
                break;
            case 29:
                op_OR(ctx);
                break;
            case 30:
                op_AND(ctx);
                break;
            case 31:
                op_GT(ctx);
                break;
            case 32:
                op_LT(ctx);
                break;
            case 33:
                op_EQ(ctx);
                break;
            case 34:
                op_NE(ctx);
                break;
            case 35:
                op_ZE(ctx);
                break;
            case 36:
                op_TRUE(ctx);
                break;
            case 37:
                op_FALSE(ctx);
                break;
            case 38:
                op_DROP(ctx);
                break;
            case 39:
                op_DUP(ctx);
                break;
            case 40:
                op_OVER(ctx);
                break;
            case 41:
                op_SWAP(ctx);
                break;
            case 42:
                op_R(ctx);
                break;
            case 43:
                op_MTR(ctx);
                break;
            case 44:
                op_RDROP(ctx);
                break;
            case 45:
                op_EMIT(ctx);
                break;
            case 46:
                op_PRINT(ctx);
                break;
            case 47:
                op_CR();
                break;
            case 48:
                op_DOT(ctx);
                break;
            case 49:
                op_DOTH(ctx);
                break;
            case 50:
                op_DOTS(ctx);
                break;
            case 51:
                op_DOTSH(ctx);
                break;
            case 52:
                op_DOTRH(ctx);
                break;
            case 53:
                op_DUMP(ctx);
                break;
            default:
                vm_irq_err(ctx, MK_ERR_BAD_OPCODE);
                ctx->halted = 1;
        };
        if(ctx->halted) {
            return;
        }
    }
    /* Making it this far means the MK_MAX_CYCLES limit was exceeded */
    vm_irq_err(ctx, MK_ERR_CPU_HOG);
    autogen_step(ctx);
};

#endif /* LIBMKB_AUTOGEN_C */
