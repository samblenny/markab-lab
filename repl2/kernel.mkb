( Copyright Â© 2022 Sam Blenny)
( SPDX-License-Identifier: MIT)
( Markab kernel)

( TODO: make this actually work)

load" mkb_autogen.mkb"  ( load definitions for opcodes, enums, and core vocab)

: here DP h@ ;       ( address for next writable dictionary location)
: curr CURRENT h@ ;  ( address for head of new definitions vocabulary)
: ctxt CONTEXT h@ ;  ( address for head of word searching vocabulary)

: hex 16 BASE w! ;
: decimal 10 BASE w! ;

: cr     10 emit ;  ( Emit newline, but call it by the traditional CR name)
: quote  34 emit ;  ( Emit quote: " )
: star   42 emit ;  ( Emit asterisk: * )
: space  32 emit ;  ( Emit one space)
: spaces  ( n -- )  1- for{ 32 emit }for ;  ( Emit n spaces)

: bye  ( Exit process by emptying the return stack, then returning)
  true EOF !  ( set the end of input flag)
;

: compiling?  ( -- bool )  ( Check if compile mode active)
  MODE @ MODE_COM =
;

( ----------------------------- )
( String struct format:         )
( Byte range   Field            )
(      0       .length: max 255 )
(    1:n       .data            )
( ----------------------------- )

: print ( addr -- )  ( Print string from address in T, first byte is length)
  a swap >a    ( save old a, new a = address of buffer from T)
  @a 1 < if{   ( if string is empty)
    >a ;       (   restore a, return)
  }if          ( else:)
  @a+ 1- for{  ( loop over string's data bytes)
    @a+ emit   (   emit next byte)
  }for >a      ( restore old value of a)
;

: DP.len   ( -- len  )  here @ ;   ( Get value of DP string length field)
: DP.data  ( -- addr )  here 1+ ;  ( Get address of DP string data field)
: IB.len   ( -- len  )  IB @ ;     ( Get value of IP string length field)
: IB.data  ( -- addr )  IB 1+ ;    ( Get address of IB string data field)

: DP.print  here print ;  ( Print string from DP)
: IB.print  IB print ;    ( Print input buffer)

: newline? ( byte -- bool )  ( Test if byte is CR or LF)
  dup 13 = swap 10 = or
;

: whitespace? ( byte -- bool )  ( Test if byte is space, tab, CR, or LF)
  dup 32 =  over 9 = or  over 13 = or  swap 10 = or
;

: IB.len=b-IB  ( old-b -- )  ( Calculate and store IBLen, restore b, reset IN)
  b- b IB -  ( calculate length of bytes copied into IB through b)
  IB ! >b    ( update length byte of IB, restore b)
  0 IN !     ( reset IN)
;

: readline            ( Read a line of text from standard input)
  b IB.data >b        ( save old b, new b = pointer to Input Buffer)
  255 for{            ( loop for up to IB capacity of 255 bytes)
    key               (   read byte from standard input, copy it to IB)
    0= if{            (   if end of stream:)
      0 IB ! 0 IN !   (     zero IB length and IN)
      >b true EOF !   (     restore old b, set end of input flag)
      rdrop ;         (     end loop, return)
    }if dup !b+       (   else: copy the byte to IB)
    newline? if{      (   if byte is a LF or CR:)
      b-              (     adjust the byte count to ignore newline)
      IB.len=b-IB     (     update IBLen with byte count, restore b, reset IN)
      rdrop ;         (     drop loop counter and return)
    }if               (   else: keep looping)
  }for IB.len=b-IB    ( update IBLen with byte count, restore b, reset IN)
;

: strcmp ( addr addr -- bool )  ( Compare strings, return match as boolean)
  a swap >a swap b swap >b   ( exchange old a & b with addresses in S & T)
  @a @b+ != if{              ( if length bytes do not match)
    >b >a false ;            (   restore old a & b, then return bool=false)
  }if
  @a+ 1- for{                ( loop over all the bytes)
    @a+ @b+ != if{           (   if bytes do not match)
      >b >a false rdrop ;    (     restore old a & b, then return bool=false)
    }if
  }for >b >a true            ( all bytes match: restore a and b, return true)
;

( ------------------------- )
( Vocab item struct format: )
( Byte range   Field        )
(    0:1       .link        )
(      2       .name.length )
(    3:n       .name.bytes  )
(      n       .type        )
(  n+1:n+m     .code/.param )
( ------------------------- )

: v.name  ( v -- .name )  ( Compute address of vocab item's .name field)
  2 +  ( skip 2 bytes to get past the .link field)
;

: v.type  ( v -- .type )  ( Compute address of vocab item's .type field)
  2 +      ( skip 2 bytes to get past the .link field)
  dup @ +  ( skip .name.length bytes to get to the end of the .name.data field)
  1+       ( adding 1 more gets us the address of the .type field)
;

: find ( voc -- [addr] bool)  ( Search for word at DP in dictionary)
  ctxt >x
  999 for{           ( loop over up to 999 dictionary entries)
    x 0= if{         ( if vocab item pointer is null:)
      false rdrop ;  (   return bool=false)
    }if x v.name     ( calculate address of vocab item's .name field)
    here strcmp      ( compare vocab item's name with search word)
    if{              ( if they match:)
      x v.type       (   calculate address of vocab item's .type field)
      true rdrop ;   (   return: addr=.type bool=true )
    }if x h@ >x      ( else: follow link and keep looping)
  }for false         ( end of loop without match: return false)
;

: inner  ( v.type -- ??? )  ( Inner interpreter: run code for one word)
  dup @ swap 1+ swap  ( S: address of .type + 1, T: value of .type field)
  dup T_VAR = if{     ( if type is variable:)
    drop              (   drop copy of .type value)
    ;                 (   return {T: address of word's .param field})
  }if T_CONST = if{   ( else if type is constant:)
    w@ ;              (   push value of the constant from .param, return)
  }if                 ( else if type is opcode or reg/imm compiled word:)
  call                (   call into .param *which had better return!*)
;

: a=IB.next  ( -- old-a )  ( Save old a, set new a = IB+1+IN)
  a        ( save old a)
  IB.data  ( get address of IB, add 1 to skip length byte)
  IN @ +   ( add value of IN, yielding address of next unread byte)
  >a       ( move address to a)
;

: IB.limit  ( -- n )  ( Calculate unread bytes left in IB to use as loop limit)
  IB.len  ( get length data in IB)
  IN @ -  ( subtract IN, giving number of unread bytes remaining in IB)
  1-      ( subtract 1 more to prepare for use as `for{` loop limit)
;

: IB.done?  ( -- bool )  ( Return true if IB has no more bytes to read)
  IN @ IB.len < 0=
;

: IN.aup  ( old-a -- )  ( Update IN from a, restore old a)
  a IB 1+ -  ( calculate a - IB + 1, yielding new value of IN)
  IN ! >a    ( update IN, restore old value a)
;

: skip_ws            ( Advance IN past leading spaces in IB's available bytes)
  a=IB.next          ( save old a, new a = addres of next unread byte of IB)
  IB.limit for{      ( loop over the unread bytes of IB)
    @a+ whitespace?  (   get a byte)
    0= if{           (   if byte was not whitespace:)
      rdrop          (     drop loop counter to prepare for return)
      a- IN.aup ;    (     update IN to the byte before a, restore a, return)
    }if              (   else: keep skipping whitespace)
  }for IN.aup        ( update IN and restore old value of a)
;

: w.bpatch  ( old-b addr -- )  ( Patch length byte of string for w-copy)
  b- b over -  ( calculate length using pointer to length byte)
  swap !       ( patch length byte with actual length of word)
  >b           ( restore old value of b)
;

: word  ( -- )       ( Copy a word from IB to dictionary at DP)
  IB.done? if{       ( if IB has no more bytes to read:)
    0 here ! ;       (   set string length at DP to 0, return)
  }if
  a=IB.next          ( save old a, new a = IB+IN)
  b here >b          ( save old b, new b = DP)
  b 0 !b+            ( save pointer to length, store initial length = 0)
  IB.limit for{      ( loop over unread bytes from IB)
    @a+ dup !b+      (   copy byte, space is okay because of the if{ b-)
    whitespace? if{  (   if byte was whitespace:)
      rdrop          (     drop loop counter to prepare for return)
      b- w.bpatch    (     calculate length, patch length byte, restore b)
      IN.aup ;       (     update IN, restore a, return)
    }if              (   else: keep looping)
  }for w.bpatch      ( patch length byte, restore b)
  IN.aup             ( update IN, restore a)
;

: (  ( Parse a comment from the input stream )
  IB.done? if{       ( if IB has no more bytes to read:)
    0 here ! ;       (   set string length at DP to 0, return)
  }if
  a=IB.next          ( save old a, new a = IB+IN)
  IB.limit for{      ( loop over unread bytes from IB)
    @a+ 41 = if{     (   if byte was a closing parenthesis)
      rdrop          (     drop loop counter to prepare for return)
      IN.aup ;       (     update IN, restore a, return)
    }if              (   else: keep looping)
  }for IN.aup        ( update IN, restore a)
; immediate

: 0-9?  ( n -- [n] bool )  ( Try to convert T from ASCII decimal digit)
  48 - dup             ( calculate n = n-'0' = n-48)
  0 < over 9 > or if{  ( if n-'0'<0 or 9<n-'0':)
    drop false ;       (   return {bool=false}, n is not a decimal digit)
  }if true             ( else: return {n bool=true}, n is a decimal digit)
;

: A-F?  ( n -- [n] bool )  ( Try to convert T from uppercase hex digit)
  65 - dup             ( calculate n = n-'A' = n-65)
  0 < over 5 > or if{  ( if n-'A'<0 or 5<n-'A':)
    drop false ;       (   return {bool=false}, n is not uppercase hex digit)
  }if 10 +             ( else: calculate n = n+10 as low digit is '0', not 'A')
  true                 ( return {n bool=true}, n is uppercase hex digit)
;

: a-f?  ( n -- [n] bool )  ( Try to convert T from lowercase hex digit)
  97 - dup             ( calculate n = n-'a' = n-97)
  0 < over 5 > or if{  ( if n-'a'<0 or 5<n-'a':)
    drop false ;       (   return {bool=false}, n is not lowercase hex digit)
  }if 10 +             ( else: calculate n = n+10 as low digit is '0', not 'a')
  true                 ( return {n bool=true}, n is lowercase hex digit)
;

: @a_atoi?  ( ascii -- [n] bool )  ( Try to convert ascii digit to integer)
  @a 0-9?             ( try simple decimal conversion first)
  BASE @ 16 = if{     ( if base is 16:)
    dup 0= if{        (   if decimal conversion fails:)
      drop @a a-f?    (     try to convert as lowercase hex digit)
      dup 0= if{      (     if that also fails:)
        drop @a A-F?  (       try to convert as uppercase hex digit)
      }if
    }if
  }if
;

( NOTE: This allows a leading '-' to negate hexadecimal numbers, which is a  )
(       little weird. But, doing it this way, with the same negation behavior)
(       for both hex and decimal, significantly simplifies the code.         )
(                                                                            )
: number ( -- [n] bool )  ( Try to parse word at DP as number in current base)
  0                  ( start number at n=0)
  false >b           ( b = false, meaning assume number is positive)
  DP.data >a         ( a = address of first string data byte)
  DP.len             ( push length of string for use as loop limit)
  a @ 45 = if{       ( if first byte of string in DP is '-':)
    true >b          (   b = true, meaning number should be negated)
    a+ 1-            (   skip the '-': increment a, decrement loop limit)
  }if
  1- for{            ( loop over each byte of word at DP)
    BASE @ *         (   scale n up by base)
    @a_atoi?         (   try to convert ASCII to integer in current base)
    0= if{           (   if byte was not an ASCII digit in current base:)
      drop           (     drop n)
      false rdrop ;  (     return {bool=false}, word is not a number)
    }if + a+         (   else: add this digit to n, advance a to next byte)
  }for
  b if{ inv 1+ }if   ( if b was set for a leading '-': negate n)
  true               ( return {n bool=true})
;

( --------------------------------------------------------------------)
( --- Begin Compiler -------------------------------------------------)
( --------------------------------------------------------------------)

: immediate        ( Change type of last word from regular to immediate)
  a                ( save old value of a)
  curr v.type >a   ( a = address of dictionary_head.type field)
  @a T_OBJ = if{   ( if .type was regular compiled word:)
    T_IMM a !      (   change type to immediate compiled word)
  }if >a           ( restore old value of a)
;

: allot ( bytes -- ) DP h@ + DP h! ;  ( Allocate dictionary space)

:  , here  ! 1 allot ;   ( store low byte of T at DP)
: h, here h! 2 allot ;   ( store low halfword of T at DP)
: w, here w! 4 allot ;   ( store full word T at DP)

: NEST+  ( -- )  ( Increment block nesting level)
  NEST dup @ 1+ swap !
;

: NEST-  ( -- )  ( Decrement block nesting level)
  NEST @ 1-    ( load value of nesting level and decrement it)
  dup 0 < if{  ( if result is < 0)
    dup xor    (   replace the result with 0)
    ( TODO: deal with error: source code has unbalanced }if or }for)
  }if NEST !   ( store the new nesting level)
;

: NESTED?  ( -- bool)  ( Is nesting level > 0, because of if{ or for{ block?)
  NEST @ 0 >
;

: create ( -- lenth-of-name )
  curr h,         ( store link to current head of dictionary at DP)
  word            ( copy name from input stream to DP)
  here @ 1+       ( calculate size of name struct: string bytes + length byte)
  allot           ( allocate dictionary space for the name)
;

: extend  ( addr -- )  ( Extend the dictionary with a new head item)
  dup CONTEXT h!  ( update context to include new name in searching)
  CURRENT h!      ( update current to so next new entry will point to this one)
;

: :                ( Start defining a new vocabulary word)
  here             ( push link address for updating dictionary pointers later)
  create           ( read name to start dictionary entry)
  T_OBJ ,          ( append type field: object code)
  MODE_COM MODE !  ( set compile mode)
  extend           ( update the dictionary pointers to include this word)
;

: update-mode        ( Clear compile mode, but only for final ; of definition)
  NESTED? 0= if{     ( if block nesting level is 0:)
    MODE_INT MODE !  (   clear compile mode)
  }if
;

: ;                     ( Return from a word)
  here 3 - LASTCALL h@  ( tail call optimizer...)
  = if{                 ( if last compiled subroutine call was 3 bytes ago:)
    JMP here 3 - !      (   change the JAL to a JMP)
    update-mode ;       (   clear compile mode if needed, then return)
  }if RET ,             ( else: compile a RET instruction)
  update-mode           ( clear compile mode if needed)
; immediate

: c-number ( n -- )  ( Compile number from T into dictionary)
  dup 0 < over 65535 > or if{  ( if n < 0 or n > 0xffff:)
    I32 , w, ;                 (   compile as 32-bit signed, return)
  }if dup 255 > if{            ( else if n > 0xff:)
    U16 , h, ;                 (   compile as 16-bit unsigned, return)
  }if U8 , ,                   ( else: compile as 8-bit unsigned)
;

: var  ( -- )  ( Add variable to dictionary)
  here     ( save link location for updating dictionary pointers)
  create   ( append name as read from text input stream)
  T_VAR ,  ( append .type=var)
  0 w,     ( append .param = I32 initialized to 0)
  extend   ( update the dictionary pointers)
;

: const  ( n -- )  ( Add constant to dictionary)
  here swap  ( save link location for updating dictionary pointers)
  create     ( append name as read from text input stream)
  T_CONST ,  ( append .type=const to dictionary)
  w,         ( append .param = T as I32 literal)
  extend     ( update the dictionary pointers)
;

: opcode  ( n -- )  ( Add opcode to dictionary)
  here swap  ( save link location for updating dictionary pointers)
  create     ( append name as read from text input stream)
  T_OP ,     ( append type=opcode)
  , RET ,    ( append .param = opcode from T, then RET)
  extend     ( update the dictionary pointers)
;

: if{ ( -- addr )  ( Start of if block)
  BZ , here 0 h, NEST+
; immediate

: }if ( addr -- )  ( End of if block)
  here swap h!   ( patch the jump target address at start of the if block)
  NEST-          ( update block nesting level)
  0 LASTCALL h!  ( prevent tail call optimizer from peeking across block edge)
; immediate

: for{ ( -- addr )  ( Start of for-loop block)
  MTR , here NEST+
; immediate

: }for ( addr -- )  ( End of for-loop block)
  BFOR ,         ( compile Branch to FOR: dec r, conditional branch, etc.)
  h,             ( compile the address for BFOR)
  NEST-          ( update nesting level)
  0 LASTCALL h!  ( prevent tail call optimizer from peeking across block edge)
; immediate

: inner-c  ( v.type -- )  ( Inner interpreter: compile code for one word)
  dup @ swap 1+ swap     ( S: address of .type + 1, T: value of .type field)
  dup T_VAR = if{        ( if type is variable:)
    drop                 (   drop copy of .type value)
    U16 , h,             (   compile T into a U16 literal)
    ;                    (   return)
  }if dup T_CONST = if{  ( else if type is constant:)
    drop                 (   drop copy of .type value)
    w@ I32 , w, ;        (   compile value from .param as I32 literal, return)
  }if dup T_OP = if{     ( else if type is constant:)
    drop                 (   drop copy of .type value)
    @ ,                  (   compile opcode from .param[0])
    ;                    (   return)
  }if T_OBJ = if{        ( else if type is regular compiled word:)
    here LASTCALL h!     (   save address of JAL for tail call optimizer)
    JAL , h,             (   compile JumpAndLink to address of .param)
    ;
  }if                    ( else type should be immediate compiled word:)
  call                   (   call into .param *which had better return!*)
;

( --------------------------------------------------------------------)
( --- End Compiler ---------------------------------------------------)
( --------------------------------------------------------------------)

: dowords             ( Interpret words from a line of text input)
  skip_ws             ( skip whitespace at start of unread bytes in IB)
  IB.done? if{        ( if IB is empty:)
    2 spaces 79 emit  ( print "  OK\n" prompt, return to end loop)
    75 emit cr ;
  }if
  here                ( save DP since next call will change it)
  word                ( try to copy a word from IB to DP)
  DP h!               ( put DP back where it was)
  find if{            ( if word is in the dictionary:)
    compiling? if{    (   if compile mode is active:)
      inner-c         (     compile this word)
      dowords ;       (     loop using tail recursion)
    }if
    inner             (   interpret word)
    dowords ;         (   loop using tail recursion)
  }if
  number              ( else: try to parse and push word as a number)
  if{                 ( if word is a number:)
    compiling? if{    (   if compile mode is active:)
      c-number        (     compile the number)
    }if
    dowords ;         (   loop using tail recursion)
  }if
  2 spaces 63 emit    ( else: print error message '  ? ')
  space DP.print cr   ( print the unknown word in quotes)
;

: outer         ( Outer interpreter)
  readline      ( get a line of text from stdin)
  dowords       ( loop over all the words of the line)
  EOF @ 0= if{  ( if the end of input flag is clear:)
    outer ;     (   use tail recursion to keep getting more lines)
  }if
;

: boot    ( Initialize global vars, print version, start outer interpreter)
  0 IN w!        ( 1 byte,  aligned 4, so zero all 4)
  0 LASTCALL w!  ( 2 bytes, aligned 4, so zero all 4)
  10 BASE w!     ( set number base to decimal)
  false EOF w!   ( clear the end of input flag)
  here fence     ( write protect dictionary up to and including this word)
  outer          ( start the outer interpreter)
;
