( Copyright Â© 2022 Sam Blenny)
( SPDX-License-Identifier: MIT)
( Markab kernel)

( TODO: make this actually work)

load" mkb_autogen.mkb"  ( load definitions for opcodes, enums, and core vocab)

: here DP h@ ;       ( address for next writable dictionary location)
: curr CURRENT h@ ;  ( address for head of new definitions vocabulary)
: ctxt CONTEXT h@ ;  ( address for head of word searching vocabulary)

: interpret? MODE @ MODE_INT = ;
: compiling? MODE @ MODE_COM = ;
: immediate? MODE @ MODE_IMM = ;

: allot ( bytes -- ) DP h@ + DP h! ;

:  , here  ! 1 allot ;   ( store low byte of T at DP)
: h, here h! 2 allot ;   ( store low halfword of T at DP)
: w, here w! 4 allot ;   ( store full word T at DP)

: NEST+    ( -- )     NEST dup @ 1+ swap ! ;  ( Increment block nesting level)
: NEST-    ( -- )     NEST dup @ 1- swap ! ;  ( Decrement block nesting level)
: NESTED?  ( -- bool) NEST @ 0 > ;            ( Is nesting level > 0?)

: create ( -- lenth-of-name )
  curr here h,  ( store link to current head of dictionary at DP)
  here          ( remember address where name will begin)
  word          ( copy name from input stream to DP)
  @             ( load string length of name from `word`)
;

: :                     ( Start defining a new vocabulary word)
  here curr             ( save dictionary state for rollback)
  create                ( read name to start dictionary entry)
  0= if{                ( if length of name was 0:)
    Current h! DP h! ;  (   roll back changes, return)
  }if MODE_COM MODE !   ( else: set compile mode)
;

: update-mode        ( Clear compile mode, but only for final ; of definition)
  NESTED? 0= if{     ( if block nesting level is 0:)
    MODE_INT MODE !  (   clear compile mode)
  }if
;

: ;                       ( Return from a word)
  here 3 - LASTCALL h@ =  ( tail call optimizer...)
  = if{                   ( if last compiled call was 3 bytes ago:)
    JUMP here 3 - !       (   change the CALL to a JUMP)
    update-mode ;         (   clear compile mode if needed, then return)
  }if RET ,               ( else: compile a RET instruction)
  update-mode             ( clear compile mode if needed)
;

: var                ( Add variable to dictionary)
  create             ( append name as read from text input stream)
  T_VAR ,            ( append type=var)
  U16 , here 3 + h,  ( append code to push parameter address at runtime)
  RET ,              ( append RET to end code and begin parameter)
  0 w,               ( append I32 parameter, initialized to 0)
;

: const ( i32 -- )  ( Add constant to dictionary)
  create            ( append name as read from text input stream)
  T_CONST ,         ( append type=const to dictionary)
  I32 , w, RET ,    ( append code to push I32 literal)
;

: opcode  ( Add opcode to dictionary)
  create  ( append name as read from text input stream)
  T_OP ,  ( append type=opcode)
  ,       ( append T as the opcode number)
;

: if{ ( -- addr ) BZ , here 0 , 0 , NEST+ ;   immediate
: }if ( addr -- ) here swap h! NEST- ;        immediate
: for{ ( -- addr ) MTR , here NEST+ ;         immediate
: }for ( addr -- ) DRBLT , h, RDROP , NEST- ; immediate

: hex 16 BASE w! ;
: decimal 10 BASE w! ;
: cr 10 emit ;
: space 32 emit ;

: newline? ( byte -- )  ( test if byte is CR or LF)
  dup 10 = 13 = or
;

: whitespace? ( byte -- )
  dup newline?              ( check for CR or LF)
  over 32 = or swap 9 = or  ( check for space or tab)
;

: readline
  0 >a TIB >b 255 for{           ( loop for maximum of 255 bytes)
    key dup !b+                  ( read stdin byte and store to TIB)
    a+                           ( update count of bytes read)
    newline? if{ rdrop 0 >r }if  ( stop for newline)
  }for a TIBLen !                ( store count of bytes read)
  0 IN !                         ( reset IN)
;

: word ( -- length-of-word )  ( Copy word from input stream to dictionary)
  IN @ >x TIB x + >a x >b     ( source: TIB+IN, b: IN+count)
  255 x - for{                ( loop to skip over leading whitespace)
    @a+ b+ dup whitespace?    ( read byte, increment count)
    0= if{ b- rdrop 0 >r }if  ( stop at first non-whitespace byte)
  }for b IN !                 ( IN = first non-whitespace byte)
  IN @ >x here >y             ( x = IN, y = address of length byte)
  0 ,                         ( store string_length=0 to dictionary)
  x 255 >= if{ drop ; }if     ( stop now if TIB is empty)
  TIB x + >a here >b          ( source: TIB+IN, dest: dictionary)
  255 x - for{                ( loop to copy non-whitespace bytes)
    @a+ dup whitespace?       ( read a byte)
    if{ drop rdrop 0 >r }if   ( stop for whitespace)
    !b+                       ( otherwise, copy it to dictionary)
  }for here y -               ( calculate string length)
  dup y !                     ( patch string length with correct count)
;

( --------------------- )
( String struct format: )
( Byte range   Field    )
(      0       .length  )
(    1:n       .bytes   )
( --------------------- )

: strcmp ( addr addr -- bool )  ( Compare strings, return match as boolean)
  a swap >a swap b swap >b   ( exchange old a & b with addresses in S & T)
  @a @b != if{               ( if length bytes do not match)
    >b >a false ;            (   restore old a & b, then return bool=false)
  }if
  @a+ 1- for{                ( loop over all the bytes)
    @a+ @b+ != if{           (   if bytes do not match)
      >b >a false rdrop ;    (     restore old a & b, then return bool=false)
    }if
  }for true                  ( return bool=true if all bytes matched)
;

( ------------------------- )
( Vocab item struct format: )
( Byte range   Field        )
(    0:1       .link        )
(      2       .name.length )
(    3:n       .name.bytes  )
(      n       .type        )
(  n+1:n+m     .code/.param )
( ------------------------- )

: v_find ( voc -- [addr] bool)  ( Search for word at DP in vocabulary at T)
  >x
  999 for{                 ( loop over up to 999 dictionary entries)
    x 0= if{               ( if vocab item pointer is null:)
      false rdrop ;        (   return bool=false)
    }if x 2 +              ( calculate address of vocab item's name field)
    here strcmp            ( compare vocab item's name with search word)
    if{                    ( if they match:)
      x 2 + dup @ +        (   calculate address of vocab item .type field)
      true rdrop ;         (   return: addr=.type bool=true )
    }if x h@ >x            ( else: follow link)
  }for
;

: find ( -- [addr] bool )  ( Search for word at DP in CORE_V and EXT_V)
  CORE_V h@ v_find if{     ( if word matches name of core vocab item:)
    true ;                 (   return: addr bool=true)
  }if EXT_V h@ v_find      ( else: try the extensible vocab)
;

: digit0-9? ( n -- [n] bool )  ( Try to convert T from ASCII decimal digit)
  48 - dup             ( calculate n = n-'0' = n-48)
  0 < swap 9 > or if{  ( if n-'0'<0 or 9<n-'0':)
    drop false ;       (   return {bool=false}, n is not a decimal digit)
  }if true             ( else: return {n bool=true}, n is a decimal digit)
;

: digitA-F? ( n -- [n] bool )  ( Try to convert T from uppercase hex digit)
  65 - dup             ( calculate n = n-'A' = n-65)
  0 < swap 5 > or if{  ( if n-'A'<0 or 5<n-'A':)
    drop false ;       (   return {bool=false}, n is not uppercase hex digit)
  }if 10 +             ( else: calculate n = n+10 as low digit is '0', not 'A')
  true                 ( return {n bool=true}, n is uppercase hex digit)
;

: digit_a-f? ( n -- [n] bool )  ( Try to convert T from lowercase hex digit)
  97 - dup             ( calculate n = n-'a' = n-97)
  0 < swap 5 > or if{  ( if n-'a'<0 or 5<n-'a':)
    drop false ;       (   return {bool=false}, n is not lowercase hex digit)
  }if 10 +             ( else: calculate n = n+10 as low digit is '0', not 'a')
  true                 ( return {n bool=true}, n is lowercase hex digit)
;

: number_10 ( -- [n] bool)  ( Try to parse word at DP as decimal number)
  a x 0                     ( save old values of a and x, start number at n=0)
  here >a                   ( a = pointer to word, which is at DP)
  false >x                  ( x = false, meaning assume number is positive)
  @a 1 > a 1+ @ 45 = and    ( calculate if first byte of word byte is '-')
  if{                       ( if first byte is '-':)
    true >x                 (   x = true, means number is negative)
  }if @a+ 1-                ( load string length and prepare loop counter)
  x if{ 1- a+ }if           ( if negative: adjust a and counter to skip '-')
  for{                      ( loop over each byte of word at DP)
    10 *                    (   scale n up by base)
    @a+ digit0-9?           (   load next byte, try to convert decimal digit)
    0= if{                  (   if byte was not a decimal digit:)
      drop >x >a            (     drop n, restore old values of a and x)
      false rdrop ;         (     return {bool=false}, word is not a number)
    }if +                   (   else: add this digit to n)
  }for x if{ inv 1+ }if     ( if x was set for a leading '-': negate n)
  swap >x swap >a           ( restore old values of a and x)
  true                      ( return {n bool=true}, word was a decimal number)
;

: number_16 ( -- [n] bool)  ( Try to parse word at DP as hex number)
  a 0                       ( save old value of a, start number at n=0)
  here >a @a+ 1- for{       ( loop over each byte of word at DP)
    16 *                    (   scale n up by base)
    @a+ dup digit0-9?       (   load next byte, try to convert as ASCII 0-9)
    0= if{                  (   if not decimal digit:)
      dup digitA-F?         (     try to convert as uppercase hex)
      0= if{                (     if not uppercase hex:)
        digit_a-f?          (       try to convert as lowercase hex)
        0= if{              (       if all the digit->int conversions failed:)
          drop >a           (         drop n, restore old value of a)
          false rdrop ;     (         return {bool=false}, not a hex number)
    }if +                   (   else: add this digit to n)
  }for swap >a              ( restore old value of a)
  true                      ( return {n bool=true}, word was a hex number)
;

: number ( -- [n] bool )  ( Try to parse word at DP as number in current base)
  BASE @ dup 10 = if{     ( if base is 10:)
    drop number_10 ;      (   attempt to parse decimal number)
  }if 16 = if{            ( else if base is 16:)
    number_16 ;           (   attempt to parse hex number)
  }if false               ( else: indicate parse failed by returning false)
;

: inner
;

: .dp          ( print word from DP)
  a here >a    ( save old a, new a = DP)
  @a+ 1- for{  ( loop according to length byte of string at DP)
    @a+ emit   (   emit the next byte)
  }for >a      ( restore old value of a)
;

: ."   ( " ( Print a string. The ( " keeps my silly syntax highlighting happy)
  a b                 ( save old values of a and b)
  IN @ >b             ( b = current value of IN)
  IB b + >a           ( a = current position in text input buffer )
  IBLen b - 1- for{   ( loop over remaining bytes of input line)
    @a+ dup 34 = if{  (   if byte is ", ASCII 34:)
      drop b IN !     (     drop the copy of the " byte, update IN)
      >b >a rdrop ;   (     restore old values of a and b, then return)
    }if emit b+       (   else: print the byte and increment copy of IN)
  }for b IN ! >b >a   ( update IN, restore old values of a and b)
;

: dowords
  word 0= if{ ."  OK" cr ; }if
  find if{ inner dowords ; }if
  number 0= if{ ." ERR: word not found:" .dp reset cr ; }if
;

: outer readline dowords outer ;

: version ." Markab v0.1.0" cr ;

: boot    ( Initialize global vars, print version, start outer interpreter)
  0 DP h!
  0 IN !
  MODE_INT MODE !
  0 LASTCALL h!
  0 NEST !
  version
  outer
;
