( Copyright Â© 2022 Sam Blenny)
( SPDX-License-Identifier: MIT)
( Markab kernel)

( TODO: make this actually work)

load" mkb_autogen.mkb"  ( load definitions for opcodes, enums, and core vocab)

: here DP h@ ;       ( address for next writable dictionary location)
: curr CURRENT h@ ;  ( address for head of new definitions vocabulary)
: ctxt CONTEXT h@ ;  ( address for head of word searching vocabulary)

: hex 16 BASE w! ;
: decimal 10 BASE w! ;

: cr     10 emit ;  ( Emit newline, but call it by the traditional CR name)
: quote  34 emit ;  ( Emit quote: " )
: star   42 emit ;  ( Emit asterisk: * )
: space  32 emit ;  ( Emit one space)
: spaces  ( n -- )  1- for{ 32 emit }for ;  ( Emit n spaces)

: bye    ( Exit process by emptying the return stack, then returning)
  reset  ( empty stacks, but particularly the return stack)
;

( ----------------------------- )
( String struct format:         )
( Byte range   Field            )
(      0       .length: max 255 )
(    1:n       .data            )
( ----------------------------- )

: print ( addr -- )  ( Print string from address in T, first byte is length)
  a swap >a    ( save old a, new a = address of buffer from T)
  @a 1 < if{   ( if string is empty)
    >a ;       (   restore a, return)
  }if          ( else:)
  @a+ 1- for{  ( loop over string's data bytes)
    @a+ emit   (   emit next byte)
  }for >a      ( restore old value of a)
;

: DP.len   ( -- len  )  here @ ;   ( Get value of DP string length field)
: DP.data  ( -- addr )  here 1+ ;  ( Get address of DP string data field)
: IB.len   ( -- len  )  IB @ ;     ( Get value of IP string length field)
: IB.data  ( -- addr )  IB 1+ ;    ( Get address of IB string data field)

: DP.print  here print ;  ( Print string from DP)
: IB.print  IB print ;    ( Print input buffer)

: newline? ( byte -- bool )  ( Test if byte is CR or LF)
  dup 13 = swap 10 = or
;

: whitespace? ( byte -- bool )  ( Test if byte is space, tab, CR, or LF)
  dup 32 =  over 9 = or  over 13 = or  swap 10 = or
;

: IB.len=b-IB  ( old-b -- )  ( Calculate and store IBLen, restore b, reset IN)
  b- b IB -  ( calculate length of bytes copied into IB through b)
  IB ! >b    ( update length byte of IB, restore b)
  0 IN !     ( reset IN)
;

: readline
  b IB.data >b        ( save old b, new b = pointer to Input Buffer)
  255 for{            ( loop for up to IB capacity of 255 bytes)
    key               (   read byte from standard input, copy it to IB)
    0= if{            (   if end of stream:)
      0 IB ! 0 IN !   (     zero IB length and IN)
      >b rdrop ;      (     restore old b, end loop, return)
    }if dup !b+       (   else: copy the byte to IB)
    newline? if{      (   if byte is a LF or CR:)
      b-              (     adjust the byte count to ignore newline)
      IB.len=b-IB     (     update IBLen with byte count, restore b, reset IN)
      rdrop ;         (     drop loop counter and return)
    }if               (   else: keep looping)
  }for IB.len=b-IB    ( update IBLen with byte count, restore b, reset IN)
;

: strcmp ( addr addr -- bool )  ( Compare strings, return match as boolean)
  a swap >a swap b swap >b   ( exchange old a & b with addresses in S & T)
  @a @b+ != if{              ( if length bytes do not match)
    >b >a false ;            (   restore old a & b, then return bool=false)
  }if
  @a+ 1- for{                ( loop over all the bytes)
    @a+ @b+ != if{           (   if bytes do not match)
      >b >a false rdrop ;    (     restore old a & b, then return bool=false)
    }if
  }for >b >a true            ( all bytes match: restore a and b, return true)
;

( ------------------------- )
( Vocab item struct format: )
( Byte range   Field        )
(    0:1       .link        )
(      2       .name.length )
(    3:n       .name.bytes  )
(      n       .type        )
(  n+1:n+m     .code/.param )
( ------------------------- )

: v.name  ( v -- .name )  ( Compute address of vocab item's .name field)
  2 +  ( skip 2 bytes to get past the .link field)
;

: v.type  ( v -- .type )  ( Compute address of vocab item's .type field)
  2 +      ( skip 2 bytes to get past the .link field)
  dup @ +  ( skip .name.length bytes to get to the end of the .name.data field)
  1+       ( adding 1 more gets us the address of the .type field)
;

: find ( voc -- [addr] bool)  ( Search for word at DP in dictionary)
  ctxt >x
  999 for{           ( loop over up to 999 dictionary entries)
    x 0= if{         ( if vocab item pointer is null:)
      false rdrop ;  (   return bool=false)
    }if x v.name     ( calculate address of vocab item's .name field)
    here strcmp      ( compare vocab item's name with search word)
    if{              ( if they match:)
      x v.type       (   calculate address of vocab item's .type field)
      true rdrop ;   (   return: addr=.type bool=true )
    }if x h@ >x      ( else: follow link and keep looping)
  }for false         ( end of loop without match: return false)
;

: inner  ( v.type -- ??? )  ( Inner interpreter: run code for one word)
  dup @ swap 1+ swap  ( S: address of .type + 1, T: value of .type field)
  dup T_VAR = if{     ( if type is variable:)
    drop              (   drop copy of .type value)
    ;                 (   return {T: address of word's .param field})
  }if T_CONST = if{   ( else if type is constant:)
    w@ ;              (   push value of the constant from .param, return)
  }if                 ( else if type is opcode or reg/imm compiled word:)
  call                (   call into .param *which had better return!*)
;

: a=IB.next  ( -- old-a )  ( Save old a, set new a = IB+1+IN)
  a        ( save old a)
  IB.data  ( get address of IB, add 1 to skip length byte)
  IN @ +   ( add value of IN, yielding address of next unread byte)
  >a       ( move address to a)
;

: IB.limit  ( -- n )  ( Calculate unread bytes left in IB to use as loop limit)
  IB.len  ( get length data in IB)
  IN @ -  ( subtract IN, giving number of unread bytes remaining in IB)
  1-      ( subtract 1 more to prepare for use as `for{` loop limit)
;

: IB.done?  ( -- bool )  ( Return true if IB has no more bytes to read)
  IN @ IB.len < 0=
;

: IN.aup  ( old-a -- )  ( Update IN from a, restore old a)
  a IB 1+ -  ( calculate a - IB + 1, yielding new value of IN)
  IN ! >a    ( update IN, restore old value a)
;

: skip_ws            ( Advance IN past leading spaces in IB's available bytes)
  a=IB.next          ( save old a, new a = addres of next unread byte of IB)
  IB.limit for{      ( loop over the unread bytes of IB)
    @a+ whitespace?  (   get a byte)
    0= if{           (   if byte was not whitespace:)
      rdrop          (     drop loop counter to prepare for return)
      a- IN.aup ;    (     update IN to the byte before a, restore a, return)
    }if              (   else: keep skipping whitespace)
  }for IN.aup        ( update IN and restore old value of a)
;

: w.bpatch  ( old-b addr -- )  ( Patch length byte of string for w-copy)
  b- b over -  ( calculate length using pointer to length byte)
  swap !       ( patch length byte with actual length of word)
  >b           ( restore old value of b)
;

: word               ( Copy a word from IB to dictionary at DP)
  IB.done? if{       ( if IB has no more bytes to read:)
    0 here ! ;       (   set string length at DP to 0, return)
  }if
  a=IB.next          ( save old a, new a = IB+IN)
  b here >b          ( save old b, new b = DP)
  b 0 !b+            ( save pointer to length, store initial length = 0)
  IB.limit for{      ( loop over unread bytes from IB)
    @a+ dup !b+      (   copy byte, space is okay because of the if{ b-)
    whitespace? if{  (   if byte was whitespace:)
      rdrop          (     drop loop counter to prepare for return)
      b- w.bpatch    (     calculate length, patch length byte, restore b)
      IN.aup ;       (     update IN, restore a, return)
    }if              (   else: keep looping)
  }for w.bpatch      ( patch length byte, restore b)
  IN.aup             ( update IN, restore a)
;

: 0-9?  ( n -- [n] bool )  ( Try to convert T from ASCII decimal digit)
  48 - dup             ( calculate n = n-'0' = n-48)
  0 < over 9 > or if{  ( if n-'0'<0 or 9<n-'0':)
    drop false ;       (   return {bool=false}, n is not a decimal digit)
  }if true             ( else: return {n bool=true}, n is a decimal digit)
;

: A-F?  ( n -- [n] bool )  ( Try to convert T from uppercase hex digit)
  65 - dup             ( calculate n = n-'A' = n-65)
  0 < over 5 > or if{  ( if n-'A'<0 or 5<n-'A':)
    drop false ;       (   return {bool=false}, n is not uppercase hex digit)
  }if 10 +             ( else: calculate n = n+10 as low digit is '0', not 'A')
  true                 ( return {n bool=true}, n is uppercase hex digit)
;

: a-f?  ( n -- [n] bool )  ( Try to convert T from lowercase hex digit)
  97 - dup             ( calculate n = n-'a' = n-97)
  0 < over 5 > or if{  ( if n-'a'<0 or 5<n-'a':)
    drop false ;       (   return {bool=false}, n is not lowercase hex digit)
  }if 10 +             ( else: calculate n = n+10 as low digit is '0', not 'a')
  true                 ( return {n bool=true}, n is lowercase hex digit)
;

: @a_atoi?  ( ascii -- [n] bool )  ( Try to convert ascii digit to integer)
  @a 0-9?             ( try simple decimal conversion first)
  BASE @ 16 = if{     ( if base is 16:)
    dup 0= if{        (   if decimal conversion fails:)
      drop @a a-f?    (     try to convert as lowercase hex digit)
      dup 0= if{      (     if that also fails:)
        drop @a A-F?  (       try to convert as uppercase hex digit)
      }if
    }if
  }if
;

( NOTE: This allows a leading '-' to negate hexadecimal numbers, which is a  )
(       little weird. But, doing it this way, with the same negation behavior)
(       for both hex and decimal, significantly simplifies the code.         )
(                                                                            )
: number ( -- [n] bool )  ( Try to parse word at DP as number in current base)
  0                  ( start number at n=0)
  false >b           ( b = false, meaning assume number is positive)
  DP.data >a         ( a = address of first string data byte)
  DP.len             ( push length of string for use as loop limit)
  a @ 45 = if{       ( if first byte of string in DP is '-':)
    true >b          (   b = true, meaning number should be negated)
    a+ 1-            (   skip the '-': increment a, decrement loop limit)
  }if
  1- for{            ( loop over each byte of word at DP)
    BASE @ *         (   scale n up by base)
    @a_atoi?         (   try to convert ASCII to integer in current base)
    0= if{           (   if byte was not an ASCII digit in current base:)
      drop           (     drop n)
      false rdrop ;  (     return {bool=false}, word is not a number)
    }if + a+         (   else: add this digit to n, advance a to next byte)
  }for
  b if{ inv 1+ }if   ( if b was set for a leading '-': negate n)
  true               ( return {n bool=true})
;

: dowords             ( Interpret words from a line of text input)
  skip_ws             ( skip whitespace at start of unread bytes in IB)
  IB.done? if{        ( if IB is empty:)
    2 spaces 79 emit  ( print "  OK\n" prompt, return to end loop)
    75 emit cr ;
  }if
  here                ( save DP since next call will change it)
  word                ( try to copy a word from IB to DP)
  DP h!               ( put DP back where it was)
  find if{            ( if word is in the dictionary:)
    inner             (   interpret word)
    dowords ;         (   loop using tail recursion)
  }if
  number              ( else: try to parse and push word as a number)
  if{                 ( if word is a number:)
    dowords ;         (   loop using tail recursion)
  }if
  2 spaces 63 emit    ( else: print error message '  ? ')
  space DP.print cr   ( print the unknown word in quotes)
;

: outer     ( Outer interpreter)
  readline  ( get a line of text from stdin)
  dowords   ( loop over all the words of the line)
  outer     ( use tail recursion to keep getting more lines indefinitely)
;

: boot    ( Initialize global vars, print version, start outer interpreter)
  0 IN w!        ( 1 byte,  aligned 4, so zero all 4)
  0 LASTCALL w!  ( 2 bytes, aligned 4, so zero all 4)
  10 BASE w!     ( set number base to decimal)
  curr 1- fence  ( write protect dictionary up to and including this word)
  outer          ( start the outer interpreter)
;
