#!/usr/bin/python3
# Copyright (c) 2022 Sam Blenny
# SPDX-License-Identifier: MIT
#

from markab_vm import VM
from tokens import (
  NOP, ADD, SUB, MUL, AND, INV, OR, XOR, SHL, SHR, SHA, EQ, GT, LT, NE, ZE,
  JMP, CALL, RET, RFROM, TOR, RESET, DROP, DUP, OVER, SWAP,
  U8, U16, I32, BFETCH, BSTORE, WFETCH, WSTORE, FETCH, STORE
)

def p(s):
  print(s, end='')

def test_push_pop():
  v = VM()
  print("=== test.vm.test_push_pop() ===")
  p(".s")
  v._dotS()
  print("( Stack capacity is 18. Trying to push 19th item will clear stack)")
  for i in range(19):
    p(f"{i} ")
    v._push(i)
    p(".s")
    v._dotS()
  print("( This time, the stack won't clear because only 18 items are pushed)")
  for i in range(18):
    p(f"{i} ")
    v._push(i)
    p(".s")
    v._dotS()
  for i in range(19):
    p("drop .s")
    v.drop()
    v._dotS()
  print()

def test_plus_minus():
  v = VM()
  print("=== test.vm.test_plus_minus() ===")
  p("-5 1 2 .s      (  -6 1 2  OK)")
  v._push(-6)
  v._push(1)
  v._push(2)
  v._dotS()
  p("+ .s             (  -6 3  OK)")
  v.plus()
  v._dotS()
  p("+ .s               (  -3  OK)")
  v.plus()
  v._dotS()
  p("drop 7 9 .s       (  7 9  OK)")
  v.drop()
  v._push(7)
  v._push(9)
  v._dotS()
  p("- .s               (  -2  OK)")
  v.minus()
  v._dotS()
  print()

def test_multiply():
  v = VM()
  print("=== test.vm.test_multiply() ===")
  p("3 -1 .s                         (  3 -1  OK)")
  v._push(3)
  v._push(-1)
  v._dotS()
  p("* .s drop                         (  -3  OK)")
  v.mul()
  v._dotS()
  v.drop()
  p("-2 hex .s decimal            ( fffffffe  OK)")
  v._push(-2)
  v._hex()
  v._dotS()
  v._decimal()
  p("dup * .s drop                      (  4  OK)")
  v.dup()
  v.mul()
  v._dotS()
  v.drop()
  p("hex 7fffffff decimal .s   (  2147483647  OK)")
  v._push(0x7fffffff)
  v._dotS()
  p("dup * .s                           (  1  OK)")
  v.dup()
  v.mul()
  v._dotS()
  print()

def test_shift():
  v = VM()
  print("=== test.vm.test_shift() ===")
  p("1 31 .s                   (  1 31  OK)")
  v._push(1)
  v._push(31)
  v._dotS()
  p("<< .s              (  -2147483648  OK)")
  v.shiftLeft()
  v._dotS()
  p("hex .s decimal        (  80000000  OK)")
  v._hex()
  v._dotS()
  v._decimal()
  p("31 >>> decimal .s           (  -1  OK)")
  v._push(31)
  v.shiftRightI32()
  v._decimal()
  v._dotS()
  p("hex .s                (  ffffffff  OK)")
  v._hex()
  v._dotS()
  p("1 >> .s decimal       (  7fffffff  OK)")
  v._push(1)
  v.shiftRightU32()
  v._dotS()
  v._decimal()
  p("decimal .s          (  2147483647  OK)")
  v._decimal()
  v._dotS()
  p("30 >> .s                      ( 1  OK)")
  v._push(30)
  v.shiftRightU32()
  v._dotS()
  p("4 << .s                     (  16  OK)")
  v._push(4)
  v.shiftLeft()
  v._dotS()
  p("2 >> .s                      (  4  OK)")
  v._push(2)
  v.shiftRightU32()
  v._dotS()
  print()

def test_bitwise():
  v = VM()
  print("=== test.vm.test_bitwise() ===")
  print("hex")
  v._hex()
  p("ffffffff 3333 & .s drop       (  3333  OK)")
  v._push(0xffffffff)
  v._push(0x3333)
  v.and_()
  v._dotS()
  v.drop()
  p("55555555 aaaa | .s drop   (  5555ffff  OK)")
  v._push(0x55555555)
  v._push(0xaaaa)
  v.or_()
  v._dotS()
  v.drop()
  p("55555555 ffff ^ .s drop   (  5555aaaa  OK)")
  v._push(0x55555555)
  v._push(0xffff)
  v.xor()
  v._dotS()
  v.drop()
  p("55555555 ~ .s drop        (  aaaaaaaa  OK)")
  v._push(0x55555555)
  v.invert()
  v._dotS()
  v.drop()
  print("decimal")
  v._decimal()
  print()

def test_literals():
  v = VM()
  print("=== test.vm.test_literals() ===")
  p("0 255 .s drop drop          (  0 255  OK)")
  code = bytearray()
  code.extend([U8, 0, U8, 255, RET])
  v._warmBoot(code, max_cycles=len(code))
  v._dotS()
  v.drop()
  v.drop()
  p("256 65535 .s drop drop  (  256 65536  OK)")
  code = bytearray()
  code.extend([U16, 0x00, 0x01])  # 256
  code.extend([U16, 0xff, 0xff])  # 65535
  code.extend([RET])
  v._warmBoot(code, max_cycles=len(code))
  v._dotS()
  v.drop()
  v.drop()
  p("65536 -1 .s drop drop    (  65536 -1  OK)")
  code = bytearray()
  code.extend([I32, 0x00, 0x00, 0x01, 0x00])  # 65536
  code.extend([I32, 0xff, 0xff, 0xff, 0xff])  # -1
  code.extend([RET])
  v._warmBoot(code, max_cycles=len(code))
  v._dotS()
  v.drop()
  v.drop()
  print()

def test_store_fetch():
  v = VM()
  print("=== test.vm.test_store_fetch() ===")
  # =====================================================
  print("( fetch words take 1 argument)")
  p("@ .s         (  Stack is empty  ERR2)")
  v.fetch()
  v._dotS()
  p("w@ .s        (  Stack is empty  ERR2)")
  v.wFetch()
  v._dotS()
  p("b@ .s        (  Stack is empty  ERR2)")
  v.bFetch()
  v._dotS()
  print("( store words take 2 arguments)")
  p("9000 ! .s              (  9000  ERR2)")
  v._push(9000)
  v.store()
  v._dotS()
  p("w! .s                  (  9000  ERR2)")
  v.wStore()
  v._dotS()
  p("b! .s                  (  9000  ERR2)")
  v.bStore()
  v._dotS()
  print("drop  OK")
  v.drop()
  # =====================================================
  print("( @ and ! addresses must be >= 0)")
  p("-1 @ .s                  (  -1  ERR3)")
  v._push(-1)
  v.fetch()
  v._dotS()
  p("w@ .s                    (  -1  ERR3)")
  v.wFetch()
  v._dotS()
  p("b@ .s                    (  -1  ERR3)")
  v.bFetch()
  v._dotS()
  p("-1 ! .s               (  -1 -1  ERR3)")
  v._push(-1)
  v.store()
  v._dotS()
  p("w! .s                 (  -1 -1  ERR3)")
  v.wStore()
  v._dotS()
  p("b! .s                 (  -1 -1  ERR3)")
  v.bStore()
  v._dotS()
  print("drop drop  OK")
  v.drop()
  v.drop()
  # =====================================================
  print("( ! address must be <= 0xffff - 3)")
  p("4 65536 ! .s        (  4 65536  ERR3)")
  v._push(4)
  v._push(65536)
  v.store()
  v._dotS()
  for i in range(4):
    (pad, code) = ("     ", "ERR3") if i<3 else ("","OK")
    stk = f"4 {65535-i}" if i<3 else "Stack is empty"
    p(f"1 - ! .s       {pad}(  {stk}  {code})")
    v._push(1)
    v.minus()
    v.store()
    v._dotS()
  # =====================================================
  print("( @ address must be <= 0xffff - 3)")
  p("65536 @ .s            (  65536  ERR3)")
  v._push(65536)
  v.fetch()
  v._dotS()
  for i in range(4):
    (pad, code) = ("", "ERR3") if i<3 else ("      ","OK")
    _t = 65535-i if i<3 else 4
    p(f"1 - @ .s              {pad}(  {_t}  {code})")
    v._push(1)
    v.minus()
    v.fetch()
    v._dotS()
  print("drop  OK")
  v.drop()
  # =====================================================
  print("( w! address must be <= 0xffff - 1)")
  p("2 65536 w! .s       (  2 65536  ERR3)")
  v._push(2)
  v._push(65536)
  v.wStore()
  v._dotS()
  for i in range(2):
    (pad, code) = ("     ", "ERR3") if i<1 else ("","OK")
    stk = f"2 {65535-i}" if i<1 else "Stack is empty"
    p(f"1 - w! .s      {pad}(  {stk}  {code})")
    v._push(1)
    v.minus()
    v.wStore()
    v._dotS()
  # =====================================================
  print("( w@ address must be <= 0xffff - 1)")
  p("65536 w@ .s           (  65536  ERR3)")
  v._push(65536)
  v.wFetch()
  v._dotS()
  for i in range(2):
    (pad, code) = ("", "ERR3") if i<1 else ("      ","OK")
    _t = 65535-i if i<1 else 2
    p(f"1 - w@ .s             {pad}(  {_t}  {code})")
    v._push(1)
    v.minus()
    v.wFetch()
    v._dotS()
  print("drop  OK")
  v.drop()
  # =====================================================
  print("( b! address must be <= 0xffff)")
  p("1 65536 b! .s       (  1 65536  ERR3)")
  v._push(1)
  v._push(65536)
  v.bStore()
  v._dotS()
  p("1 - b! .s      (  Stack is empty  OK)")
  v._push(1)
  v.minus()
  v.bStore()
  v._dotS()
  print("( b@ address must be <= 0xffff)")
  p("65536 b@ .s           (  65536  ERR3)")
  v.drop()
  v._push(65536)
  v.bFetch()
  v._dotS()
  p("1 - b@ .s                   (  1  OK)")
  v._push(1)
  v.minus()
  v.bFetch()
  v._dotS()
  print("drop  OK")
  v.drop()
  # =====================================================
  print("( ! and @ cover full signed int32 range )")
  print("( note: @ does sign extension)")
  p("-1 9000 ! 9000 @               (  -1  OK)")
  v._push(-1)
  v._push(9000)
  v.store()
  v._push(9000)
  v.fetch()
  v._dotS()
  p("1 >> 9000 ! 9000 @ .s  (  2147483647  OK)")
  v._push(1)
  v.shiftRightU32()
  v._push(9000)
  v.store()
  v._push(9000)
  v.fetch()
  v._dotS()
  print("drop  OK")
  v.drop()
  # =====================================================
  print("( w! and w@ clip to unsigned uint16 range)")
  print("( note: w@ does not do sign extension)")
  p("-1 9000 w! 9000 w@          (  65535  OK)")
  v._push(-1)
  v._push(9000)
  v.wStore()
  v._push(9000)
  v.wFetch()
  v._dotS()
  p("1 >> 9000 w! 9000 w@ .s     (  32767  OK)")
  v._push(1)
  v.shiftRightU32()
  v._push(9000)
  v.wStore()
  v._push(9000)
  v.wFetch()
  v._dotS()
  print("drop  OK")
  v.drop()
  # =====================================================
  print("( b! and b@ clip to unsigned uint8 range)")
  print("( note: b@ does not do sign extension)")
  p("-1 9000 b! 9000 b@            (  255  OK)")
  v._push(-1)
  v._push(9000)
  v.bStore()
  v._push(9000)
  v.bFetch()
  v._dotS()
  p("1 >> 9000 b! 9000 b@ .s       (  127  OK)")
  v._push(1)
  v.shiftRightU32()
  v._push(9000)
  v.bStore()
  v._push(9000)
  v.bFetch()
  v._dotS()
  print("drop  OK")
  v.drop()
  print()

def test_return_stack():
  v = VM()
  print("=== test.vm.test_return_stack() ===")
  p(".s            (  Stack is empty  OK)")
  v._dotS()
  p(".ret        (  R-Stack is empty  OK)")
  v._dotRet()
  p(" 1 2 3 .s              (  1 2 3  OK)")
  v._push(1)
  v._push(2)
  v._push(3)
  v._dotS()
  p(">r >r >r .ret          (  3 2 1  OK)")
  v.toR()
  v.toR()
  v.toR()
  v._dotRet()
  p(".s            (  Stack is empty  OK)")
  v._dotS()
  p("r> r> r> .s            (  1 2 3  OK)")
  v.rFrom()
  v.rFrom()
  v.rFrom()
  v._dotS()
  p(".ret        (  R-Stack is empty  OK)")
  v._dotRet()
  # =====================================================
  print("( attempt to overflow return stack)")
  print("( note: overflow auto-resets both stacks)")
  p("reset 99 .s                (  99 OK)")
  v.reset()
  v._push(99)
  v._dotS()
  p(".ret        (  R-Stack is empty  OK)")
  v._dotRet()
  for i in range(18):
    p(f"{i} >r .ret")
    v._push(i)
    v.toR()
    v._dotRet()
  p(".s             (  Stack is empty OK)")
  v._dotS()
  # =====================================================
  print("( attempt to underflow return stack)")
  p("reset 99 .s               (  99  OK)")
  v.reset()
  v._push(99)
  v._dotS()
  for i in range(17):
    p(f"{i} >r .ret")
    v._push(i)
    v.toR()
    v._dotRet()
  for i in range(17):
    p(f"r> .ret")
    v.rFrom()
    v._dotRet()
  p(".s             (  99 16 ... 1 0  OK)")
  v._dotS()
  p("r> .ret   (  R-Stack is empty  ERR7)")
  v.rFrom()
  v._dotRet()
  p(".s            (  Stack is empty  OK)")
  v._dotS()
  print()

def test_comparisons():
  v = VM()
  print("=== test.vm.test_comparisons() ===")
  p("reset 1 2 =   2 2 =   2 1 =   .s   (  0 -1 0  OK)")
  v.reset()
  v._push(1)
  v._push(2)
  v.equal()
  v._push(2)
  v._push(2)
  v.equal()
  v._push(2)
  v._push(1)
  v.equal()
  v._dotS()
  v.reset()
  # =====================================================
  p("reset 1 2 >   2 2 >   2 1 >   .s   (  0 0 -1  OK)")
  v.reset()
  v._push(1)
  v._push(2)
  v.greater()
  v._push(2)
  v._push(2)
  v.greater()
  v._push(2)
  v._push(1)
  v.greater()
  v._dotS()
  # =====================================================
  p("reset 1 2 <   2 2 <   2 1 <   .s   (  -1 0 0  OK)")
  v.reset()
  v._push(1)
  v._push(2)
  v.less()
  v._push(2)
  v._push(2)
  v.less()
  v._push(2)
  v._push(1)
  v.less()
  v._dotS()
  # =====================================================
  p("reset 1 2 <>  2 2 <>  2 1 <>  .s  (  -1 0 -1  OK)")
  v.reset()
  v._push(1)
  v._push(2)
  v.notEq()
  v._push(2)
  v._push(2)
  v.notEq()
  v._push(2)
  v._push(1)
  v.notEq()
  v._dotS()
  # =====================================================
  p("reset  -1 0=    0 0=    1 0=  .s   (  0 -1 0  OK)")
  v.reset()
  v._push(-1)
  v.zeroEq()
  v._push(0)
  v.zeroEq()
  v._push(1)
  v.zeroEq()
  v._dotS()
  print()

def test_over_swap():
  v = VM()
  print("=== test.vm.test_over_swap() ===")
  p("1 2 over .s                         (  1 2 1  OK)")
  v._push(1)
  v._push(2)
  v.over()
  v._dotS()
  p("swap .s                             (  1 1 2  OK)")
  v.swap()
  v._dotS()
  print()

def test_instruction_decode_math_logic():
  v = VM()
  print("=== test.vm.test_instruction_decode_math_logic() ===")
  print("( opcode coverage: NOP ADD SUB MUL                     )")
  print("( equivalent to: 1 dup + dup 9 - dup *                 )")
  print("ASM{ nop U8 1 dup add dup U8 9 sub dup mul ret }ASM")
  code = bytearray([NOP, U8, 1, DUP, ADD, DUP, U8, 9, SUB, DUP, MUL, RET])
  v._warmBoot(code, max_cycles=9)
  print("warmboot  OK")
  p(".s                                          (  2 49  OK)")
  v._dotS()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: AND INV OR XOR                      )")
  print("( equivalent to: hex 55 ~ 7f and dup 80 or 0f xor      )")
  print("ASM{ U8 85 inv U8 127 and dup U8 128 or U8 15 xor ret }ASM")
  code = bytearray([U8, 85, INV, U8, 127, AND, DUP, U8, 128, OR])
  code.extend([U8, 15, XOR, RET])
  v._warmBoot(code, max_cycles=99)
  print("warmboot  OK")
  p("hex .s decimal                             (  2a a5  OK)")
  v._hex()
  v._dotS()
  v._decimal()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: SHL SHR SHA                         )")
  print("( equivalent to: 1 31 << dup 15 >>> dup 16 >>          )")
  print("ASM{  ret }ASM")
  code = bytearray([U8, 1, U8, 31, SHL, DUP, U8, 15, SHA, DUP])
  code.extend([U8, 16, SHR, RET])
  v._warmBoot(code, max_cycles=99)
  print("warmboot  OK")
  p("hex .s decimal             (  8000000 ffff0000 ffff  OK)")
  v._hex()
  v._dotS()
  v._decimal()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: EQ                                  )")
  print("( equivalent to: 1 2 =     2 2 =   2 1 =               )")
  print("ASM{ u8 1 u8 2 eq  u8 2 u8 2 eq  u8 2 u8 1 eq  ret }ASM")
  code = bytearray([U8,1,U8,2,EQ, U8,2,U8,2,EQ, U8,2,U8,1,EQ, RET])
  p("warmboot .s                               (  0 -1 0  OK)")
  v._warmBoot(code, max_cycles=99)
  v._dotS()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: GT                                  )")
  print("( equivalent to: 1 2 >     2 2 >   2 1 >               )")
  print("ASM{ u8 1 u8 2 gt  u8 2 u8 2 gt  u8 2 u8 1 gt  ret }ASM")
  code = bytearray([U8,1,U8,2,GT, U8,2,U8,2,GT, U8,2,U8,1,GT, RET])
  p("warmboot .s                               (  0 0 -1  OK)")
  v._warmBoot(code, max_cycles=99)
  v._dotS()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: LT                                  )")
  print("( equivalent to: 1 2 <     2 2 <   2 1 <               )")
  print("ASM{ u8 1 u8 2 lt  u8 2 u8 2 lt  u8 2 u8 1 lt  ret }ASM")
  code = bytearray([U8,1,U8,2,LT, U8,2,U8,2,LT, U8,2,U8,1,LT, RET])
  p("warmboot .s                               (  -1 0 0  OK)")
  v._warmBoot(code, max_cycles=99)
  v._dotS()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: NE                                  )")
  print("( equivalent to: 1 2 <>    2 2 <>  2 1 <>              )")
  print("ASM{ u8 1 u8 2 ne  u8 2 u8 2 ne  u8 2 u8 1 ne  ret }ASM")
  code = bytearray([U8,1,U8,2,NE, U8,2,U8,2,NE, U8,2,U8,1,NE, RET])
  p("warmboot .s                              (  -1 0 -1  OK)")
  v._warmBoot(code, max_cycles=99)
  v._dotS()
  print("reset  OK")
  v.reset()
  print("( opcode coverage: ZE                                  )")
  print("( equivalent to:  -1 0=    0 0=      1 0=              )")
  print("ASM{ i32 255 255 255 255 ze  u8 0 ze  u8 1 ze  ret }ASM")
  code = bytearray([I32,255,255,255,255,ZE, U8,0,ZE, U8,1,ZE, RET])
  p("warmboot .s                               (  0 -1 0  OK)")
  v._warmBoot(code, max_cycles=99)
  v._dotS()
  print("reset  OK")
  v.reset()
  print()

def test_instruction_decode_jump():
  v = VM()
  print("=== test.vm.test_instruction_decode_jump() ===")
  print("( opcode coverage: JMP                                 )")
  print("( assemble tokens to memory starting at Boot vector 256)")
  print("( 256+0: push 5                                        )")
  print("( 256+2: jump to 256+8                                 )")
  print("( 256+5: push 6, return                                )")
  print("( 256+8: push 7, jump to 256+5                         )")
  print("(   256+:   0 1   2 3 4    5 6   7    8 9  10 11 12    )")
  print("ASM{ U8 5 jmp 8 1 U8 6 ret U8 7 jmp  5  1 }ASM")
  code = bytearray()
  code.extend([U8, 5, JMP, 8, 1, U8, 6, RET, U8, 7, JMP, 5, 1])
  v._warmBoot(code, max_cycles=6)  # U8 jmp U8 jmp U8 ret
  print("warmboot  OK")
  p(".s                                         (  5 7 6  OK)")
  v._dotS()
  print()

def test_instruction_decode_call_return():
  v = VM()
  print("=== test.vm.test_instruction_decode_call_return() ===")
  print("( opcode coverage: CALL RET                            )")
  print("( assemble tokens to memory starting at Boot vector 256)")
  print("( 256+ 0: Call 256+7=0x0107, or [7, 1] little endian   )")
  print("( 256+ 3: Call 256+10=0x010A, or [10, 1] little endian )")
  print("( 256+ 6: Return                                       )")
  print("( 256+ 7: Subroutine: push 9 to data stack, return     )")
  print("( 256+10: Subroutine: push 5 to data stack, return     )")
  print("(   256+:   0 1 2    3  4 5   6    7 8   9   10 11  12 )")
  print("ASM{ call 7 1 call 10 1 ret U8 9 ret U8  5 ret }ASM")
  code = bytearray()
  code.extend([CALL, 7, 1, CALL, 10, 1, RET, U8, 9, RET, U8, 5, RET])
  v._warmBoot(code, max_cycles=7)  # call U8 ret call U8 ret ret
  print("warmboot  OK")
  p(".s                                           (  9 5  OK)")
  v._dotS()
  print()

test_push_pop()
test_plus_minus()
test_multiply()
test_shift()
test_bitwise()
test_literals()
test_store_fetch()
test_return_stack()
test_comparisons()
test_over_swap()
test_instruction_decode_math_logic()
test_instruction_decode_jump()
test_instruction_decode_call_return()
