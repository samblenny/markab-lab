=== test.vm.test_push_pop() ===
.s  Stack is empty  OK
( Stack capacity is 18. Trying to push 19th item will clear stack)
0 .s  0  OK
1 .s  0 1  OK
2 .s  0 1 2  OK
3 .s  0 1 2 3  OK
4 .s  0 1 2 3 4  OK
5 .s  0 1 2 3 4 5  OK
6 .s  0 1 2 3 4 5 6  OK
7 .s  0 1 2 3 4 5 6 7  OK
8 .s  0 1 2 3 4 5 6 7 8  OK
9 .s  0 1 2 3 4 5 6 7 8 9  OK
10 .s  0 1 2 3 4 5 6 7 8 9 10  OK
11 .s  0 1 2 3 4 5 6 7 8 9 10 11  OK
12 .s  0 1 2 3 4 5 6 7 8 9 10 11 12  OK
13 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13  OK
14 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  OK
15 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  OK
16 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  OK
17 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  OK
18 .s  Stack is empty  ERR1
( This time, the stack won't clear because only 18 items are pushed)
0 .s  0  OK
1 .s  0 1  OK
2 .s  0 1 2  OK
3 .s  0 1 2 3  OK
4 .s  0 1 2 3 4  OK
5 .s  0 1 2 3 4 5  OK
6 .s  0 1 2 3 4 5 6  OK
7 .s  0 1 2 3 4 5 6 7  OK
8 .s  0 1 2 3 4 5 6 7 8  OK
9 .s  0 1 2 3 4 5 6 7 8 9  OK
10 .s  0 1 2 3 4 5 6 7 8 9 10  OK
11 .s  0 1 2 3 4 5 6 7 8 9 10 11  OK
12 .s  0 1 2 3 4 5 6 7 8 9 10 11 12  OK
13 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13  OK
14 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  OK
15 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  OK
16 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  OK
17 .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10 11 12 13  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10 11 12  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10 11  OK
drop .s  0 1 2 3 4 5 6 7 8 9 10  OK
drop .s  0 1 2 3 4 5 6 7 8 9  OK
drop .s  0 1 2 3 4 5 6 7 8  OK
drop .s  0 1 2 3 4 5 6 7  OK
drop .s  0 1 2 3 4 5 6  OK
drop .s  0 1 2 3 4 5  OK
drop .s  0 1 2 3 4  OK
drop .s  0 1 2 3  OK
drop .s  0 1 2  OK
drop .s  0 1  OK
drop .s  0  OK
drop .s  Stack is empty  OK
drop .s  Stack is empty  ERR2

=== test.vm.test_plus_minus() ===
-5 1 2 .s      (  -6 1 2  OK)  -6 1 2  OK
+ .s             (  -6 3  OK)  -6 3  OK
+ .s               (  -3  OK)  -3  OK
drop 7 9 .s       (  7 9  OK)  7 9  OK
- .s               (  -2  OK)  -2  OK

=== test.vm.test_multiply() ===
3 -1 .s                         (  3 -1  OK)  3 -1  OK
* .s drop                         (  -3  OK)  -3  OK
-2 hex .s decimal            ( fffffffe  OK)  fffffffe  OK
dup * .s drop                      (  4  OK)  4  OK
hex 7fffffff decimal .s   (  2147483647  OK)  2147483647  OK
dup * .s                           (  1  OK)  1  OK

=== test.vm.test_shift() ===
1 31 .s                   (  1 31  OK)  1 31  OK
<< .s              (  -2147483648  OK)  -2147483648  OK
hex .s decimal        (  80000000  OK)  80000000  OK
31 >>> decimal .s           (  -1  OK)  -1  OK
hex .s                (  ffffffff  OK)  ffffffff  OK
1 >> .s decimal       (  7fffffff  OK)  7fffffff  OK
decimal .s          (  2147483647  OK)  2147483647  OK
30 >> .s                      ( 1  OK)  1  OK
4 << .s                     (  16  OK)  16  OK
2 >> .s                      (  4  OK)  4  OK

=== test.vm.test_bitwise() ===
hex
ffffffff 3333 & .s drop       (  3333  OK)  3333  OK
55555555 aaaa | .s drop   (  5555ffff  OK)  5555ffff  OK
55555555 ffff ^ .s drop   (  5555aaaa  OK)  5555aaaa  OK
55555555 ~ .s drop        (  aaaaaaaa  OK)  aaaaaaaa  OK
decimal

=== test.vm.test_literals() ===
0 255 .s drop drop          (  0 255  OK)  0 255  OK
256 65535 .s drop drop  (  256 65536  OK)  256 65535  OK
65536 -1 .s drop drop    (  65536 -1  OK)  65536 -1  OK

=== test.vm.test_store_fetch() ===
( fetch words take 1 argument)
@ .s         (  Stack is empty  ERR2)  Stack is empty  ERR2
w@ .s        (  Stack is empty  ERR2)  Stack is empty  ERR2
b@ .s        (  Stack is empty  ERR2)  Stack is empty  ERR2
( store words take 2 arguments)
9000 ! .s              (  9000  ERR2)  9000  ERR2
w! .s                  (  9000  ERR2)  9000  ERR2
b! .s                  (  9000  ERR2)  9000  ERR2
drop  OK
( @ and ! addresses must be >= 0)
-1 @ .s                  (  -1  ERR3)  -1  ERR3
w@ .s                    (  -1  ERR3)  -1  ERR3
b@ .s                    (  -1  ERR3)  -1  ERR3
-1 ! .s               (  -1 -1  ERR3)  -1 -1  ERR3
w! .s                 (  -1 -1  ERR3)  -1 -1  ERR3
b! .s                 (  -1 -1  ERR3)  -1 -1  ERR3
drop drop  OK
( ! address must be <= 0xffff - 3)
4 65536 ! .s        (  4 65536  ERR3)  4 65536  ERR3
1 - ! .s            (  4 65535  ERR3)  4 65535  ERR3
1 - ! .s            (  4 65534  ERR3)  4 65534  ERR3
1 - ! .s            (  4 65533  ERR3)  4 65533  ERR3
1 - ! .s       (  Stack is empty  OK)  Stack is empty  OK
( @ address must be <= 0xffff - 3)
65536 @ .s            (  65536  ERR3)  65536  ERR3
1 - @ .s              (  65535  ERR3)  65535  ERR3
1 - @ .s              (  65534  ERR3)  65534  ERR3
1 - @ .s              (  65533  ERR3)  65533  ERR3
1 - @ .s                    (  4  OK)  4  OK
drop  OK
( w! address must be <= 0xffff - 1)
2 65536 w! .s       (  2 65536  ERR3)  2 65536  ERR3
1 - w! .s           (  2 65535  ERR3)  2 65535  ERR3
1 - w! .s      (  Stack is empty  OK)  Stack is empty  OK
( w@ address must be <= 0xffff - 1)
65536 w@ .s           (  65536  ERR3)  65536  ERR3
1 - w@ .s             (  65535  ERR3)  65535  ERR3
1 - w@ .s                   (  2  OK)  2  OK
drop  OK
( b! address must be <= 0xffff)
1 65536 b! .s       (  1 65536  ERR3)  1 65536  ERR3
1 - b! .s      (  Stack is empty  OK)  Stack is empty  OK
( b@ address must be <= 0xffff)
65536 b@ .s           (  65536  ERR3)  65536  ERR3
1 - b@ .s                   (  1  OK)  1  OK
drop  OK
( ! and @ cover full signed int32 range )
( note: @ does sign extension)
-1 9000 ! 9000 @               (  -1  OK)  -1  OK
1 >> 9000 ! 9000 @ .s  (  2147483647  OK)  2147483647  OK
drop  OK
( w! and w@ clip to unsigned uint16 range)
( note: w@ does not do sign extension)
-1 9000 w! 9000 w@          (  65535  OK)  65535  OK
1 >> 9000 w! 9000 w@ .s     (  32767  OK)  32767  OK
drop  OK
( b! and b@ clip to unsigned uint8 range)
( note: b@ does not do sign extension)
-1 9000 b! 9000 b@            (  255  OK)  255  OK
1 >> 9000 b! 9000 b@ .s       (  127  OK)  127  OK
drop  OK

=== test.vm.test_return_stack() ===
.s            (  Stack is empty  OK)  Stack is empty  OK
.ret        (  R-Stack is empty  OK)  R-Stack is empty  OK
 1 2 3 .s              (  1 2 3  OK)  1 2 3  OK
>r >r >r .ret          (  3 2 1  OK)  3 2 1  OK
.s            (  Stack is empty  OK)  Stack is empty  OK
r> r> r> .s            (  1 2 3  OK)  1 2 3  OK
.ret        (  R-Stack is empty  OK)  R-Stack is empty  OK
( attempt to overflow return stack)
( note: overflow auto-resets both stacks)
reset 99 .s                (  99 OK)  99  OK
.ret        (  R-Stack is empty  OK)  R-Stack is empty  OK
0 >r .ret  0  OK
1 >r .ret  0 1  OK
2 >r .ret  0 1 2  OK
3 >r .ret  0 1 2 3  OK
4 >r .ret  0 1 2 3 4  OK
5 >r .ret  0 1 2 3 4 5  OK
6 >r .ret  0 1 2 3 4 5 6  OK
7 >r .ret  0 1 2 3 4 5 6 7  OK
8 >r .ret  0 1 2 3 4 5 6 7 8  OK
9 >r .ret  0 1 2 3 4 5 6 7 8 9  OK
10 >r .ret  0 1 2 3 4 5 6 7 8 9 10  OK
11 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11  OK
12 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12  OK
13 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13  OK
14 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  OK
15 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  OK
16 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  OK
17 >r .ret  R-Stack is empty  ERR6
.s             (  Stack is empty OK)  Stack is empty  OK
( attempt to underflow return stack)
reset 99 .s               (  99  OK)  99  OK
0 >r .ret  0  OK
1 >r .ret  0 1  OK
2 >r .ret  0 1 2  OK
3 >r .ret  0 1 2 3  OK
4 >r .ret  0 1 2 3 4  OK
5 >r .ret  0 1 2 3 4 5  OK
6 >r .ret  0 1 2 3 4 5 6  OK
7 >r .ret  0 1 2 3 4 5 6 7  OK
8 >r .ret  0 1 2 3 4 5 6 7 8  OK
9 >r .ret  0 1 2 3 4 5 6 7 8 9  OK
10 >r .ret  0 1 2 3 4 5 6 7 8 9 10  OK
11 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11  OK
12 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12  OK
13 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13  OK
14 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  OK
15 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  OK
16 >r .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  OK
r> .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  OK
r> .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  OK
r> .ret  0 1 2 3 4 5 6 7 8 9 10 11 12 13  OK
r> .ret  0 1 2 3 4 5 6 7 8 9 10 11 12  OK
r> .ret  0 1 2 3 4 5 6 7 8 9 10 11  OK
r> .ret  0 1 2 3 4 5 6 7 8 9 10  OK
r> .ret  0 1 2 3 4 5 6 7 8 9  OK
r> .ret  0 1 2 3 4 5 6 7 8  OK
r> .ret  0 1 2 3 4 5 6 7  OK
r> .ret  0 1 2 3 4 5 6  OK
r> .ret  0 1 2 3 4 5  OK
r> .ret  0 1 2 3 4  OK
r> .ret  0 1 2 3  OK
r> .ret  0 1 2  OK
r> .ret  0 1  OK
r> .ret  0  OK
r> .ret  R-Stack is empty  OK
.s             (  99 16 ... 1 0  OK)  99 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  OK
r> .ret   (  R-Stack is empty  ERR7)  R-Stack is empty  ERR7
.s            (  Stack is empty  OK)  Stack is empty  OK

=== test.vm.test_comparisons() ===
reset 1 2 =   2 2 =   2 1 =   .s   (  0 -1 0  OK)  0 -1 0  OK
reset 1 2 >   2 2 >   2 1 >   .s   (  0 0 -1  OK)  0 0 -1  OK
reset 1 2 <   2 2 <   2 1 <   .s   (  -1 0 0  OK)  -1 0 0  OK
reset 1 2 <>  2 2 <>  2 1 <>  .s  (  -1 0 -1  OK)  -1 0 -1  OK
reset  -1 0=    0 0=    1 0=  .s   (  0 -1 0  OK)  0 -1 0  OK

=== test.vm.test_over_swap() ===
1 2 over .s                         (  1 2 1  OK)  1 2 1  OK
swap .s                             (  1 1 2  OK)  1 1 2  OK

=== test.vm.test_instruction_decode_math_logic() ===
( opcode coverage: NOP ADD SUB MUL                     )
( equivalent to: 1 dup + dup 9 - dup *                 )
ASM{ nop U8 1 dup add dup U8 9 sub dup mul ret }ASM
warmboot  OK
.s                                          (  2 49  OK)  2 49  OK
reset  OK
( opcode coverage: AND INV OR XOR                      )
( equivalent to: hex 55 ~ 7f and dup 80 or 0f xor      )
ASM{ U8 85 inv U8 127 and dup U8 128 or U8 15 xor ret }ASM
warmboot  OK
hex .s decimal                             (  2a a5  OK)  2a a5  OK
reset  OK
( opcode coverage: SHL SHR SHA                         )
( equivalent to: 1 31 << dup 15 >>> dup 16 >>          )
ASM{  ret }ASM
warmboot  OK
hex .s decimal             (  8000000 ffff0000 ffff  OK)  80000000 ffff0000 ffff  OK
reset  OK
( opcode coverage: EQ                                  )
( equivalent to: 1 2 =     2 2 =   2 1 =               )
ASM{ u8 1 u8 2 eq  u8 2 u8 2 eq  u8 2 u8 1 eq  ret }ASM
warmboot .s                               (  0 -1 0  OK)  0 -1 0  OK
reset  OK
( opcode coverage: GT                                  )
( equivalent to: 1 2 >     2 2 >   2 1 >               )
ASM{ u8 1 u8 2 gt  u8 2 u8 2 gt  u8 2 u8 1 gt  ret }ASM
warmboot .s                               (  0 0 -1  OK)  0 0 -1  OK
reset  OK
( opcode coverage: LT                                  )
( equivalent to: 1 2 <     2 2 <   2 1 <               )
ASM{ u8 1 u8 2 lt  u8 2 u8 2 lt  u8 2 u8 1 lt  ret }ASM
warmboot .s                               (  -1 0 0  OK)  -1 0 0  OK
reset  OK
( opcode coverage: NE                                  )
( equivalent to: 1 2 <>    2 2 <>  2 1 <>              )
ASM{ u8 1 u8 2 ne  u8 2 u8 2 ne  u8 2 u8 1 ne  ret }ASM
warmboot .s                              (  -1 0 -1  OK)  -1 0 -1  OK
reset  OK
( opcode coverage: ZE                                  )
( equivalent to:  -1 0=    0 0=      1 0=              )
ASM{ i32 255 255 255 255 ze  u8 0 ze  u8 1 ze  ret }ASM
warmboot .s                               (  0 -1 0  OK)  0 -1 0  OK
reset  OK

=== test.vm.test_instruction_decode_jump() ===
( opcode coverage: JMP                                 )
( assemble tokens to memory starting at Boot vector 256)
( 256+0: push 5                                        )
( 256+2: jump to 256+8                                 )
( 256+5: push 6, return                                )
( 256+8: push 7, jump to 256+5                         )
(   256+:   0 1   2 3 4    5 6   7    8 9  10 11 12    )
ASM{ U8 5 jmp 8 1 U8 6 ret U8 7 jmp  5  1 }ASM
warmboot  OK
.s                                         (  5 7 6  OK)  5 7 6  OK

=== test.vm.test_instruction_decode_call_return() ===
( opcode coverage: CALL RET                            )
( assemble tokens to memory starting at Boot vector 256)
( 256+ 0: Call 256+7=0x0107, or [7, 1] little endian   )
( 256+ 3: Call 256+10=0x010A, or [10, 1] little endian )
( 256+ 6: Return                                       )
( 256+ 7: Subroutine: push 9 to data stack, return     )
( 256+10: Subroutine: push 5 to data stack, return     )
(   256+:   0 1 2    3  4 5   6    7 8   9   10 11  12 )
ASM{ call 7 1 call 10 1 ret U8 9 ret U8  5 ret }ASM
warmboot  OK
.s                                           (  9 5  OK)  9 5  OK

=== test.vm.test_instruction_decode_jz() ===
( opcode coverage: JZ                                  )
( equivalent to 0 IF{ 7 }IF 0 0= IF{ 8 }IF             )
( 256+:  0 1  2 3 4  5 6  7 8  9 10 11 12 13 14  15    )
ASM{    U8 0 JZ 7 1 U8 7 U8 0 ZE JZ 15  1 U8  8 RET }ASM
(          0 if{       7 }if                           )
(                           0 0= if{          8 }if    )
warmboot  OK
.s                                        (  0 -1 8  OK)  0 -1 8  OK

=== test.vm.test_instruction_decode_drjnn_rpush_rpop() ===
( opcode coverage: DRJNN TOR RFROM                     )
(    equivalent to: 3 for{ i }for                      )
( which expands to: 3 >r :FOR r> dup >r jrnz :FOR      )
( and assembled at the Boot vector, 256, looks like... )
( 256+: 0 1   2        3   4   5     6 7  8     9   10  11)
ASM{   U8 3 TOR    RFROM DUP TOR DRJNN 3  1 RFROM DROP RET }ASM
(         3 for{               i }FOR                  )
(           >r :FOR   r> dup  >r drjnn :FOR    >r drop )
warmboot  OK
.s                                       (  3 2 1 0  OK)  3 2 1 0  OK

